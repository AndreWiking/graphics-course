#version 430

layout(local_size_x = 32, local_size_y = 32) in;

layout(push_constant) uniform param_shared_type{
  uint screen_size_x;
  uint screen_size_y;
  float mouse_pos_x;
  float mouse_pos_y;
  float time;
} param_shared;

layout(binding = 0, rgba8) uniform image2D resultImage;

vec2 iResolution;           // viewport resolution (in pixels)
float iTime = 0.0;
vec2 iMouse;

const vec3  eye      = vec3 ( 0, 0, 5 );
const vec3  light    = vec3  ( 0.0, 3.0, 5.0 );
const int   maxSteps = 70;
const float eps      = 0.01;
#define PI 3.1415926538



// Rotation matrix around the X axis.
mat3 rotateX(float theta) {
    float c = cos(theta);
    float s = sin(theta);
    return mat3(
        vec3(1, 0, 0),
        vec3(0, c, -s),
        vec3(0, s, c)
    );
}

// Rotation matrix around the Y axis.
mat3 rotateY(float theta) {
    float c = cos(theta);
    float s = sin(theta);
    return mat3(
        vec3(c, 0, s),
        vec3(0, 1, 0),
        vec3(-s, 0, c)
    );
}

// Rotation matrix around the Z axis.
mat3 rotateZ(float theta) {
    float c = cos(theta);
    float s = sin(theta);
    return mat3(
        vec3(c, s, 0),
        vec3(-s, c, 0),
        vec3(0, 0, 1)
    );
}


float sdLink( vec3 p, float le, float r1, float r2 )
{
  vec3 q = vec3( p.x, max(abs(p.y)-le,0.0), p.z );
  return length(vec2(length(q.xy)-r1,q.z)) - r2;
}


float sdVerticalCapsule( vec3 p, float h, float r )
{
  p.y -= clamp( p.y, 0.0, h );
  return length( p ) - r;
}


float sdRoundedCylinder( vec3 p, float ra, float rb, float h )
{
  vec2 d = vec2( length(p.xz)-2.0*ra+rb, abs(p.y) - h );
  return min(max(d.x,d.y),0.0) + length(max(d,0.0)) - rb;
}

vec3  clr  = vec3 ( 0, 0, 0 );

const vec3  outline2_clr  = vec3(2, 2, 0.4);
const vec3 outline1_clr  = vec3(0.1, 2.1, 0.1);
const vec3 capsule_clr  = vec3(2.1, 0.1, 0.1);
const vec3 ground_clr  = vec3(1.1, 1.1, 2.1);

float smoothUnion ( float d1, float d2, float k ) 
{
    float h = clamp( 0.5 + 0.5*(d2-d1)/k, 0.0, 1.0 );

    return mix( d2, d1, h ) - k*h*(1.0-h); 
}

float sdf ( in vec3 p, in mat3 m)
{
   vec3 q = m * p;
   
   
   float capsule_h = 1.0, capsule_r = 0.3;
   
   float capsule1 = sdVerticalCapsule(q * rotateZ(PI * 0.0), capsule_h, capsule_r);
   float capsule2 = sdVerticalCapsule(q * rotateZ(PI * 0.5), capsule_h, capsule_r);
   float capsule3 = sdVerticalCapsule(q * rotateZ(PI * 1.0), capsule_h, capsule_r);
   float capsule4 = sdVerticalCapsule(q * rotateZ(PI * 1.5), capsule_h, capsule_r);
   
   float res_min = min(capsule1, min(capsule2, min(capsule3, capsule4)));
   
   float outline1_rot_speed = 2.6, outline2_rot_speed = -2.0;
   float outline_le = 0.2, outline_r1 = 1.6, outline_r2 = 0.1;
   
   vec3 q_off = q + vec3(0, 0, outline_r2 / 2.0);
   vec3 q1 = rotateY(iTime * outline1_rot_speed) * q_off;
   vec3 q2 = rotateX(iTime * outline2_rot_speed) * q_off;
   
   float outline1 = sdLink(q1, outline_le, outline_r1, outline_r2);

   float outline2 = sdLink(q2, outline_le, outline_r1 * 1.3, outline_r2);
      
   float ground = sdRoundedCylinder(q - vec3(0, 2.5, 0), 0.8, 0.2, 0.05);
  
   
   clr = capsule_clr;
   if (outline1 < res_min) {
       res_min = outline1;
       clr = outline1_clr;
   }
   if (outline2 < res_min) {
       res_min = outline2;
       clr = outline2_clr;
   }
   if (ground < res_min) {
       clr = ground_clr;
   }
     
   return smoothUnion(ground, res_min, 0.3);
}



vec3 trace ( in vec3 from, in vec3 dir, out bool hit, in mat3 m )
{
	vec3	p         = from;
	float	totalDist = 0.0;
	
	hit = false;
	
	for ( int steps = 0; steps < maxSteps; steps++ )
	{
		float	dist = sdf ( p, m );
        
		if ( dist < 0.01 )
		{
			hit = true;
			break;
		}
		
		totalDist += dist;
		
		if ( totalDist > 10.0 )
			break;
			
		p += dist * dir;
	}
	
	return p;
}

vec3 generateNormal ( vec3 z, float d, in mat3 m )
{
    float e   = max (d * 0.5, eps );
    float dx1 = sdf(z + vec3(e, 0, 0), m);
    float dx2 = sdf(z - vec3(e, 0, 0), m);
    float dy1 = sdf(z + vec3(0, e, 0), m);
    float dy2 = sdf(z - vec3(0, e, 0), m);
    float dz1 = sdf(z + vec3(0, 0, e), m);
    float dz2 = sdf(z - vec3(0, 0, e), m);
    
    return normalize ( vec3 ( dx1 - dx2, dy1 - dy2, dz1 - dz2 ) );
}

const float roughness = 0.2;
const vec3  r0   = vec3 ( 1.0, 0.92, 0.23 );
const float gamma = 2.2;
const float pi    = 3.1415926;
const float FDiel = 0.04;		// Fresnel for dielectrics

vec3 fresnel ( in vec3 f0, in float product )
{
	product = clamp ( product, 0.0, 1.0 );		// saturate
	
	return mix ( f0, vec3 (1.0), pow(1.0 - product, 5.0) );
}

float D_blinn(in float roughness, in float NdH)
{
    float m = roughness * roughness;
    float m2 = m * m;
    float n = 2.0 / m2 - 2.0;
    return (n + 2.0) / (2.0 * pi) * pow(NdH, n);
}

float D_beckmann ( in float roughness, in float NdH )
{
	float m    = roughness * roughness;
	float m2   = m * m;
	float NdH2 = NdH * NdH;
	
	return exp( (NdH2 - 1.0) / (m2 * NdH2) ) / (pi * m2 * NdH2 * NdH2);
}

float D_GGX ( in float roughness, in float NdH )
{
	float m  = roughness * roughness;
	float m2 = m * m;
	float NdH2 = NdH * NdH;
	float d  = (m2 - 1.0) * NdH2 + 1.0;
	
	return m2 / (pi * d * d);
}

float G_schlick ( in float roughness, in float nv, in float nl )
{
    float k = roughness * roughness * 0.5;
    float V = nv * (1.0 - k) + k;
    float L = nl * (1.0 - k) + k;
	
    return 0.25 / (V * L);
}

float G_neumann ( in float nl, in float nv )
{
	return nl * nv / max ( nl, nv );
}

float G_klemen ( in float nl, in float nv, in float vh )
{
	return nl * nv / (vh * vh );
}

float G_default ( in float nl, in float nh, in float nv, in float vh )
{
	return min ( 1.0, min ( 2.0*nh*nv/vh, 2.0*nh*nl/vh ) );
}

vec4 cookTorrance ( in vec3 p, in vec3 n, in vec3 l, in vec3 v )
{
    vec3  h    = normalize ( l + v );
	float nh   = dot (n, h);
	float nv   = dot (n, v);
	float nl   = dot (n, l);
	float vh   = dot (v, h);
    float metallness = 1.0;
    vec3  base  = pow ( clr, vec3 ( gamma ) );
    vec3  F0    = mix ( vec3(FDiel), clr, metallness );
	
			// compute Beckman
   	float d = D_beckmann ( roughness, nh );

            // compute Fresnel
    vec3 f = fresnel ( F0, nv );
	
            // default G
    float g = G_default ( nl, nh, nv, vh );
	
			// resulting color
	vec3  ct   = f*(0.25 * d * g / nv);
	vec3  diff = max(nl, 0.0) * ( vec3 ( 1.0 ) - f ) / pi;
	float ks   = 0.5;

	return vec4 ( pow ( diff * base + ks * ct, vec3 ( 1.0 / gamma ) ), 1.0 );
}

void mainImage( out vec4 fragColor, in vec2 fragCoord )
{

        // Normalized pixel coordinates (from 0 to 1)
    bool hit;
	vec3 mouse = vec3(iMouse.xy/iResolution.xy - 0.5, 0.0);
    mat3 m     = rotateX ( 6.0*mouse.y ) * rotateY ( 6.0*mouse.x);
    vec2 scale = 9.0 * iResolution.xy / max ( iResolution.x, iResolution.y ) ;
    vec2 uv    = scale * ( fragCoord/iResolution.xy - vec2 ( 0.5 ) );
	vec3 dir   = normalize ( vec3 ( uv, 0 ) - eye );
    vec4 color = vec4 ( 0.0, 0.0, 0.0, 1 );
    vec3 p     = trace ( eye, dir, hit, m );


	if ( hit )
	{
		vec3  l  = normalize        ( light - p );
        vec3  v  = normalize        ( eye - p );
		vec3  n  = generateNormal   ( p, 0.001, m );
		float nl = max ( 0.0, dot ( n, l ) );
        vec3  h  = normalize ( l + v );
        float hn = max ( 0.0, dot ( h, n ) );
        float sp = pow ( hn, 150.0 );
		
        color = cookTorrance ( p, n, l, v );
	} 

        // Output to screen
    fragColor = color * 6.0;
}


void main()
{
  ivec2 uv = ivec2(gl_GlobalInvocationID.xy); 

  // TODO: Put your shadertoy code here!
  // Simple gradient as a test.

  iResolution = vec2(param_shared.screen_size_x, param_shared.screen_size_y);
  iMouse = vec2(param_shared.mouse_pos_x, param_shared.mouse_pos_y);
  iTime = param_shared.time;

  vec4 fragColor;
  vec2 fragCoord = vec2(gl_GlobalInvocationID.xy);
  mainImage(fragColor, fragCoord);

  if (uv.x < 1280 && uv.y < 720)
    imageStore(resultImage, uv, fragColor);
}
